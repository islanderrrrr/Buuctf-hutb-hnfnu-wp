# 挑战简介
dp:即泄露了私钥d和p，所以称之为部分私钥泄露

# 思路
当dp被泄露时，我们可以利用以下关系式：

1. dp = d mod (p-1)
2. e·d ≡ 1 (mod φ(n))
3. e·d ≡ 1 (mod (p-1))
4. e·dp ≡ 1 (mod (p-1))

所以总共步骤即是
- 找到素数p
- 找到q和私钥d
- 解密

```
#!/usr/bin/python3
import gmpy2 as gp

e = 65537
n = 157667866005866043809675592336288962106125998780791920007920833145068421861029354497045918471672956655205541928071253023208751202980457919399456984628429198438149779785543371372206661553180051432786094530268099696823142821724314197245158942206348670703497441629288741715352106143317909146546420870645633338871
dp = 2509050304161548479367108202753097217949816106531036020623500808413533337006939302155166063392071003278307018323129989037561756887882853296553118973548769
c = 127916287434936224964530288403657504450134210781148845328357237956681373722556447001247137686758965891751380034827824922625307521221598031789165449134994998397717982461775225812413476283147124013667777578827293691666320739053915493782515447112364470583788127477537555786778672970196314874316507098162498135060


for i in range(1,e):                   
    if(dp*e-1)%i == 0:
        if n%(((dp*e-1)//i)+1) == 0:   
            p=((dp*e-1)//i)+1
            q=n//(((dp*e-1)//i)+1)
            phi=(q-1)*(p-1)            
            d=gp.invert(e,phi)         
            m=pow(c,d,n)               
           
print(m)                              

print(bytes.fromhex(hex(m)[2:]))      

```
